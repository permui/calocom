Module = { SOI ~ ImportBlock ~ DefinitionBlock ~ EOI }

ImportBlock = { ImportItem* }
ImportItem = _{ "import" ~ Path }

Path = { ident ~ ( "." ~ ident)* }

DefinitionBlock = { Definition* }
Definition = _{ DataDefinition | FunctionDefinition }

DataDefinition = { "data" ~ DataTypeName ~ "=" ~ ConstructorList ~ ";" }
ConstructorList = { Constructor ~ ("|" ~ Constructor)* }
Constructor = { ConstructorName ~ ( "(" ~ Type ~ ")" )? }

FunctionDefinition = {
    FunctionName ~ ":" ~ "(" ~ ParameterList ~ ")" ~ "->" ~ Type ~
    BracketExpression
}

ParameterList = {
    ( NameTypeBind ~ ( "," ~ NameTypeBind )* ) | ""
}
NameTypeBind = _{
    AtNameTypeBind 
  | OrdNameTypeBind 
}

AtNameTypeBind = { "@" ~ VariableName ~ ":" ~ Type }
OrdNameTypeBind = { VariableName ~ ":" ~ Type }

BracketExpression = _{ "{" ~ BracketBody ~ "}" }
BracketBody = { (Statement)* ~ Expression? }
Statement = { StatementBody ~ ";" }
StatementBody = _{
    StatementBodyLet | StatementBodyAsgn | Expression
}
StatementBodyLet = { "let" ~ VariableName ~ ":" ~ Type ~ "=" ~ Expression }
StatementBodyAsgn = { VariableName ~ "=" ~ Expression }

// Expression = {
//     BracketExpression
//   | MatchExpression
//   | CallExpression
//   | ArithmeticExpression
// }

// arithmetic expression part start

Expression = { aexp }

// left associative
op = { "+" | "-" }
aexp = { aexp1 ~ (op ~ aexp1)* }

op1 = { "*" | "/" | "%" }
aexp1 = { aexp2 ~ (op1 ~ aexp2)* }

aexp2 = { MatchExpression | BracketExpression | CallExpression | Literal | VariableName | aexp3 }

aexp3 = { "(" ~ Expression ~ ")" }

// arithmetic expression part end

AtArgument = { "@" ~ VariableName }

ArgumentExpression = {
    AtArgument | Expression 
}

CallExpression = { Path ~ GenericNotation? ~ "(" ~ ArgumentList ~ ")" }
GenericNotation = { "<" ~ Type ~ ">" }
ArgumentList = {
    ArgumentExpression ~ ( "," ~ ArgumentExpression )* 
  | ""
}

Literal = { integer_lit | string_lit | bool_lit }

MatchExpression = {
    "match" ~ Expression ~ "{" ~ MatchArmList ~ "}"
}

MatchArmList = { MatchArm ~ ("," ~ MatchArm)* }

MatchArm = { Pattern ~ "=>" ~ Expression } 

Pattern = {
    ConstructorName ~ ( "(" ~ VariableName ~ ")" )?
  | Literal
}

// Type is not just a name
// it should be a valid type.
// type part start

// type constructors are: tuple, arrow
// we don't allow tuple of 1 element
// or say, (T) will not be considered a tuple, 
// but a parenthesis around T
// this will be used in cases like a function returning
// (i32 -> i32) -> i32

Type = { type0 }

type0 = { type1 ~ ("->" ~ type1)* }
type1 = { unit_type | tuple_type | TypeName }

unit_type = { "(" ~ ")" }
tuple_type = { "(" ~ type0 ~ ("," ~ type0)* ~ ")" }


// type part end

DataTypeName = @{ ident }
ConstructorName = @{ ident }
TypeName = @{ ident }
FunctionName = @{ ident }
VariableName = @{ ident } 

ident = @{ (LETTER | "_") ~ (LETTER | NUMBER | "_")* }
integer_lit = @{ ("+" | "-")? ~ ASCII_DIGIT+ }
string_lit = ${ "\"" ~ string_lit_inner ~ "\"" }
string_lit_inner = @{ ("\\\\" | "\\\"" | (!"\"" ~ ANY))* }
bool_lit = @{ "true" | "false" }

WHITESPACE = _{ " " | "\t" | "\n" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
