import std.io

data List<T> = Nil | Con(T, List<T>) ;

data Option<T> = None | Some(T) ;

synonym Map<K, V> = List<(K, V)> ;

update<K, V> : (@m: Map<K, V>, key: K, val: V) -> () {
	m = Con<(K, V)>((key, val), m);
}

newMap<K, V>: () -> Map<K, V> {
	Nil<(K, V)>
}

lookup<K, V>: (m: Map<K, V>, key: K) -> Option<V> {
	match m {
		Nil<(K, V)> => None<V>,
		Con<(K, V)>((k, v), xs) => if k == key { Some<V>(v) } else { lookup<K, V>(xs, key) }
	}
}

main: () -> () {
	let m : Map<i32, i32> = newMap<i32, i32>();

	update<i32, i32>(@m, 2, 3);

	update<i32, i32>(@m, 4, 5);

	let z : i32 = lookup<i32, i32>(m, 2);

	io.println<i32>(z);
}
